<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>06_Array(배열)객체-1</title>
  <script src="js/output.js"></script>
  <script>
    // js 코드 작성 
    var idx = ['0', '1', '2', '3', '4']; //[] 배열의 형태  // 이런식으로 저장을 하면 배열객체
    var ary = ['a', 'b', 'c', 'd', 'e'];
    prn('배열의 index 값 : ' + idx);
    prn('ary에 저장된 값 : ' + ary);
    line();
    prn('[배열 ary의 길이(개수)] ary.length : ' + ary.length); //5 .length 배열 갯수 구하기  
    line();
    prn('[배열의 2번부터 추출] ary.slice(2) : ' + ary.slice(2)); //c,d,e 잘라오는 것 인덱스 번호 2번부터
    // 없으면 끝까지
    prn('[배열의 1번부터 3번 전까지 추출] ary.slice(1, 3) : ' + ary.slice(1, 3)); //b,c 
    line();
    prn('[배열의 각 요소를 "/"로 연결] ary.join(" / ") : ' + ary.join(' / ')); //a / b / c / d / e 
    //내가 지정한 문자들 사이에 슬러시를 넣겠다 
    line(); 
   
    prn('[배열의 1번부터 3번까지 추출] ary.splice(1, 3, "g", "h", "i") : ' + ary.splice(1, 3, 'g',
      'h', 'i')); //b, c, d가 뽑혀 나오고 출력 뽑힌 배열 그자리에 g.h.i 그대로 붙여높은다   잘라서 붙이기
    prn('-> 추출 후 그 자리에 g, h, i 삽입 : ' + ary); //a, g, h, i, e 
   
    prn('[배열의 1번부터 3번까지 추출] ary.splice(1, 3) : ' + ary.splice(1, 3)); //g, h, i 
    prn('-> 추출 후 배열 ary : ' + ary); //a,e 
    line();
    prn('[배열의 마지막 요소 제거] ary.pop() : ' + ary.pop()); //e 맨뒤에 꺼 하나 뽑아냄 
    prn('-> 제거(pop) 후 배열 ary : ' + ary); //a 그냥 배열에는 a하나 남음
    prn('[배열의 마지막 요소에 f 삽입 후 배열의 개수] ary.push("f") : ' + ary.push('f')); 
    //2 밀어놓고 결과값 안에 몇개가 있냐를 나타내고
    prn('-> 삽입(push) 후 배열 ary : ' + ary); //a, f 배열은 이렇게 있다. 
    line();
    prn('[배열을 왼쪽으로 이동시 0번 요소] ary.shift() : ' + ary.shift()); //a  이동 첫번째 요소를 뺀다
    prn('-> 이동(shift) 후 배열 ary : ' + ary); //f 
    prn('[배열을 오른쪽으로 이동하면서 0번 요소에 x를 추가한 후 배열의 개수] ary.unshift("x") : ' + ary.unshift('x')); //2 오른쪽으로 추가한다. 
    prn('-> 이동(unshift) 후 배열 ary : ' + ary); //x, f 
    line();
    prn('[배열 요소의 반전] ary.reverse() : ' + ary.reverse()); //f, x 반전한다. 배열 순서 바꾸기 
    line();
    //스택구조 통에 무엇이가 집어 넣으면 무엇인가 쌓이고 계속 중첩되어 쌓이는데 이것을 푸쉬
    //쌓인 것을 제일 나중에 넣것을 빼는 것을 팝  가장 나중에 들어간 것이 가장 먼저 나오는 개념
    // 리포 lifo구조
    //큐구조 통에 손잡이가 있는데 잡아 당기면 밑에 입구가 열린다. 똑같이 무엇인가를 쌓아서 중첩시키고
    // 손잡이를 잡아당겨 맨밑에 입구를 열어 맨 처음 넣었던 무엇인가를 바로 빼낸다
    // 처음 넣은 걸 바로 뺀다. flfo피포구조

    //둘다 순서에 관련이 있다.
    //cpu코어가 여러개 있어도 동시에 처리하는 게 아니라 나눠서 한다는 개념이다.
  
    var addAry = ['javascript', 'jQuery'];
    var newAry = ary.concat(addAry); //ary.concat(addAry); 괄호 안을 결합을 하다.
    prn('[배열 ary의 값] ary : ' + ary); //f, x 
    prn('[배열 addAry의 값] addAry : ' + addAry); //javascript, jQuery 
    prn('[newAry = ary.concat( addAry ) 후 newAry 의 값] newAry : ' + newAry); //f, x, javascript, jQuery 
    line();

    var aryNum = [2, 41, 11, 23, 8];
    prn('[배열 aryNum에 저장된 값] aryNum : ' + aryNum);
    line();
    aryNum.sort(function (a, b) {  //배열들을 비교를 하면서 작은 것 부터 정렬을 한다.
      return a - b; 
    });// 배열안의 요소들을 작은 순서부터 정렬을다.
    prn('[오름차순 정렬] aryNum.sort( function (a, b) { return a - b; } ); 결과 : ' + aryNum); //2, 8, 11, 23, 41 
    aryNum.sort(function (a, b) {
      return b - a; //내림차순으로 정렬
    });
    prn('[내림차순 정렬] aryNum.sort( function (a, b) { return b - a; } ); 결과 : ' + aryNum); //41, 23, 11, 8, 2 
  </script>
  <style>
  </style>
</head>

<body>
</body>

</html>